import torch

import backgammon_env
import model
import network
import tesauro


def test_predictability_of_network():
    random_seed = 42

    if torch.cuda.is_available():
        torch.cuda.manual_seed(random_seed)
    torch.manual_seed(random_seed)

    nn = network.layered(198, 40, 4)

    b = backgammon_env.Backgammon()
    s = b.s0(player_1=True)
    tensor = tesauro.observe(s)
    v = nn(tensor).tolist()
    expected = [
        0.3743259906768799,
        0.5034601092338562,
        0.4764396548271179,
        0.43971505761146545,
    ]
    assert v == expected


def test_predictability_of_network_after_train():
    random_seed = 42

    if torch.cuda.is_available():
        torch.cuda.manual_seed(random_seed)
    torch.manual_seed(random_seed)

    nn = network.layered(198, 40, 4)

    b = backgammon_env.Backgammon()
    s = b.s0(player_1=True)
    m = ((8, 5), (6, 5))
    s1 = b.next(s, m)
    observe = tesauro.observe
    trainer = model.Trainer(b, nn, observe)

    v = nn(observe(s))

    v1 = nn(observe(s1))

    assert v.tolist() == [
        0.3743259906768799,
        0.5034601092338562,
        0.4764396548271179,
        0.43971505761146545,
    ]
    assert v1.tolist() == [
        0.37185654044151306,
        0.5025563836097717,
        0.47492071986198425,
        0.43810516595840454,
    ]

    trainer.train(v1.dot(network.utility_tensor()).item(), s)

    assert nn(observe(s)).tolist() == [
        0.37418854236602783,
        0.5033813714981079,
        0.47652003169059753,
        0.43986862897872925,
    ]
    assert nn(observe(s1)).tolist() == [
        0.3717195987701416,
        0.5024778246879578,
        0.4750007390975952,
        0.43825823068618774,
    ]


def test_evaluations_of_single_game_play():
    random_seed = 42
    if torch.cuda.is_available():
        torch.cuda.manual_seed(random_seed)
    torch.manual_seed(random_seed)
    nn = network.layered(198, 20, 4)
    bck = backgammon_env.Backgammon()
    trainer = model.Trainer(bck, nn, tesauro.observe)

    for i in range(5):
        trainer.td_episode(i)

    s = bck.s0(player_1=True)
    evaluations = []

    dice = None
    while True:
        (d1, d2) = tuple(torch.randint(1, 7, (2,)).tolist())
        if d1 != d2:
            dice = (d1, d2)
            break

    rolls = []
    while True:
        evaluations.append(trainer.v(s).item())
        if bck.done(s):
            break
        else:
            rolls.append(dice)
            move = trainer.best(s, dice)
            s = bck.next(s, move)
            dice = tuple(torch.randint(1, 7, (2,)).tolist())

    assert rolls == [
        (3, 2),
        (5, 4),
        (1, 3),
        (5, 6),
        (6, 1),
        (1, 1),
        (4, 5),
        (1, 5),
        (3, 2),
        (2, 3),
        (5, 2),
        (6, 5),
        (2, 2),
        (3, 4),
        (2, 1),
        (5, 6),
        (3, 2),
        (3, 4),
        (5, 6),
        (2, 4),
        (5, 1),
        (6, 4),
        (1, 5),
        (1, 5),
        (3, 3),
        (2, 3),
        (2, 5),
        (5, 2),
        (4, 5),
        (4, 2),
        (2, 4),
        (1, 2),
        (5, 5),
        (5, 5),
        (2, 4),
        (3, 1),
        (5, 3),
        (4, 3),
        (4, 3),
        (3, 3),
        (5, 6),
        (2, 2),
        (1, 1),
        (4, 6),
        (1, 3),
        (2, 3),
        (3, 2),
        (1, 6),
        (5, 2),
        (1, 4),
        (6, 2),
        (2, 3),
        (1, 4),
        (1, 3),
        (3, 3),
        (5, 6),
        (6, 4),
        (4, 5),
        (5, 4),
        (1, 3),
        (4, 5),
        (4, 6),
        (3, 1),
        (4, 2),
        (1, 6),
        (4, 2),
        (5, 2),
        (5, 4),
        (5, 4),
        (1, 5),
        (3, 2),
        (2, 4),
        (5, 2),
        (5, 2),
        (3, 1),
    ]

    assert evaluations == [
        -0.3964681625366211,
        -0.3930906057357788,
        -0.4013833999633789,
        -0.3983325958251953,
        -0.40426862239837646,
        -0.40045201778411865,
        -0.40355074405670166,
        -0.404788613319397,
        -0.394550085067749,
        -0.39228034019470215,
        -0.4078974723815918,
        -0.4071228504180908,
        -0.4064474105834961,
        -0.3996870517730713,
        -0.40432488918304443,
        -0.4054527282714844,
        -0.4062950611114502,
        -0.40175890922546387,
        -0.39756619930267334,
        -0.3989295959472656,
        -0.4018974304199219,
        -0.39943253993988037,
        -0.39938879013061523,
        -0.3973102569580078,
        -0.3982851505279541,
        -0.39191222190856934,
        -0.401608943939209,
        -0.4003793001174927,
        -0.40128469467163086,
        -0.4010124206542969,
        -0.40017950534820557,
        -0.3960697650909424,
        -0.3969646692276001,
        -0.403550386428833,
        -0.40099871158599854,
        -0.39925551414489746,
        -0.398745059967041,
        -0.39853429794311523,
        -0.4003114700317383,
        -0.40288376808166504,
        -0.40183961391448975,
        -0.40622782707214355,
        -0.40934181213378906,
        -0.4048449993133545,
        -0.40332484245300293,
        -0.3984043598175049,
        -0.3971320390701294,
        -0.3954761028289795,
        -0.40059518814086914,
        -0.398939847946167,
        -0.39983153343200684,
        -0.3971618413925171,
        -0.3951234817504883,
        -0.3901737928390503,
        -0.39159107208251953,
        -0.3845996856689453,
        -0.38138413429260254,
        -0.3917841911315918,
        -0.3938720226287842,
        -0.3906214237213135,
        -0.3934832811355591,
        -0.3921213150024414,
        -0.393710732460022,
        -0.3883882761001587,
        -0.38915586471557617,
        -0.39030182361602783,
        -0.38658857345581055,
        -0.39066576957702637,
        -0.38767170906066895,
        -0.39174747467041016,
        -0.39344239234924316,
        -0.3911139965057373,
        -0.38817477226257324,
        -0.3795076608657837,
        -0.37639594078063965,
        -0.3764427900314331,
    ]
